---
title: Java GUI组件动态变化问题及Thread的run()与start()区别
date: 2018-10-25 13:15:50
tags: [Java, 多线程]
categories: [Java, 多线程]
---

近来，用 Java Swing 做一个抽奖的程序，为了观赏性高一些，抽奖时 JLabel 上的号码会一直变化。当我实现好功能测试时却发现，当我按下按钮后，界面卡住了，并没有出现预期的效果，JLabel 上的数字并不变化， 只是在最终显示出最终的结果。

原来，因为 `JavaSwing` 中，界面刷新是线程同步的，同一时间只有一个线程能执行刷新界面的代码，上例中，多次调用 `setText()` 方法，均是在主线程中调用，造成线程阻塞，线程并没有退出，所以界面刷新线程不能获得执行刷新的机会，而最后一次 `setText()` 后，线程退出，界面才能执行刷新，只能看到最后一次的值，如果多次不断地刷新，必须把代码放到一个单独的线程中，从而刷新界面。

**Code**

```Java
new Thread(newRunnable(){
    
	@Override
	public void run(){
	//代码放在单独的线程中
        for(int i=1; i<=10; i++) {
            for(int j=1; j<=6; j++) {
                jl.setText("" + j);
                Thread.Sleep(10);	//省略了异常的处理
            }
        }
	}
}).start();
```

一开始，我把 `start()` 写成了 `run()` ，发现程序还是没有变化，不是预期的结果，= w =，不太熟悉 Java 的我抱着试一试的态度换成了 `start()`， 没想到居然成功了！

于是引出了下一个问题， 在 Thread 中两个方法有什么区别。

1.start（）方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码： 通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体， 它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止， 而CPU再运行其它线程。

2.run（）方法当作普通方法的方式调用，程序还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码： 而如果直接用Run方法， 这只是调用一个方法而已， 程序中依然只有主线程--这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。